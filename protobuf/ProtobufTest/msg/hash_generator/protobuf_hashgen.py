#!/usr/bin/python3
#   Developer : Alexey Zakharov (alexey.zakharov@gmail.com)
#   MD5 hash generator from protobuf messages for nanopb types.

import os
import re
import hashlib
import datetime
import argparse

PACKAGE = "package"
MESSAGE = "message"
ENUM = "enum"
SEMICOLON = ';'
EXTEND = "extend"
HASH_SIZE = 4


def read_file(path):
    with open(path, 'r', encoding='utf-8') as f:
        return f.read()


def findPackage(data):
    packageName = ""
    packNameStart = data.find(PACKAGE)
    package_len = len(PACKAGE)
    if packNameStart >= 0:
        packNameStart += package_len
        packNameEnd = data.find(SEMICOLON, packNameStart)
        packageName = data[packNameStart:packNameEnd]

    return packageName


def findExtensions(data):
    start = 0
    start = data.find(EXTEND, start)
    if start >= 0:
        print("Warning: Found extensions. Extensions are not supported.")


def findMessage(data):
    return findKeyword(data, MESSAGE)


def findEnum(data):
    return findKeyword(data, ENUM)


def findKeyword(data, keyword):
    messages = dict()
    start = 0
    keyword_len = len(keyword)

    while start >= 0:
        start = data.find(keyword, start)
        if start >= 0:
            bracket = 0  # counting brackets, when is 0, message is closed
            start = start + keyword_len
            end = start
            message = ""
            for c in data[start:]:
                if c == '{':
                    if len(message) == 0:
                        message = data[start:end]  # obtaining message name

                    bracket += 1
                elif c == '}':
                    bracket = bracket - 1

                    if bracket == 0:
                        break

                end += 1

            substr = data[start:end + 1].encode('utf-8')
            h = hashlib.md5()
            h.update(substr)
            md = h.hexdigest()
            a = int(md[:8], 16)
            b = int(md[8:16], 16)
            c = int(md[16:24], 16)
            d = int(md[24:32], 16)
            hash32 = hex(a ^ b ^ c ^ d)
            if hash32 in messages:
                raise ValueError('Hash collision detected')
            messages[hash32] = message
            start = end

    return messages


# def hexToStr(hexNum):
#     n = 2
#     s = ", ".join([str(int(hexNum[i:i + n], HASH_SIZE)) for i in range(0, len(hexNum), n)])
#
#     return s


def generateJson(packageName, messages):
    # generating body

    code = "[\n"

    for key in messages:
        type = messages[key]
        code = code + "    {\n" \
                      "        \"type\": \"" + packageName + "." + type + "\",\n" \
                                                                          "        \"hash\": \"" + str(key) + "\"\n" \
                                                                                                              "    },\n"

    code = code.rstrip(",\n")
    code = code + "\n]\n"

    return code


def generateCpp(packageName, messages, filename_output="UNDEFINED", filename_input="UNDEFINED"):
    # generating static header
    code = "/* Automatically generated hashes for nanopb types */\n" \
           "/* Generated by proto_hashgen from " + filename_input + " at " + datetime.datetime.now().strftime(
        "%c") + ". */\n" \
                "#ifndef " + filename_output.upper() + "_INCLUDED\n" \
                                                       "#define " + filename_output.upper() + "_INCLUDED\n\n" \
                                                                                              "namespace " + packageName + " {\n\n" \
                                                                                                                           "template <class T>\n" \
                                                                                                                           "constexpr uint32_t getHash(void)\n" \
                                                                                                                           "{\n" \
                                                                                                                           "    return 0;\n" \
                                                                                                                           "}\n\n"

    # generating body
    for key in messages:
        type = messages[key]
        code = code + "template <>\n" \
                      "constexpr uint32_t getHash<" + packageName + "_" + type + ">()\n" \
                                                                                 "{\n" \
                                                                                 "    return " + str(key) + ";\n" \
                                                                                                            "}\n\n"

    code += "constexpr int getHashSize(void)\n" \
            "{\n" \
            "    return " + str(HASH_SIZE) + ";\n" \
                                             "}\n\n" \
                                             "} //namespace " + packageName + "\n\n" \
 \
        # generating static footer
    code += "#endif\n"

    return code


def generateCsharp(packageName, messages, filename_output="UNDEFINED", filename_input="UNDEFINED"):
    # generating static header
    code = "/* Automatically generated hashes for protobuf types */\n" \
           "/* Generated by proto_hashgen from " + filename_input + " at " + datetime.datetime.now().strftime(
        "%c") + ". */\n" \
                "namespace " + packageName.capitalize() + "\n{\n" \
                                                          "\tpublic static class Hash\n"\
                                                          "\t{\n" \
                                                          "\t\tpublic static uint Get<T>()\n" \
                                                          "\t\t{\n" \
                                                          "\t\t\tType typeId = typeof(T);\n"
    # generating body
    for key in messages:
        type = messages[key]
        code = code + "\t\t\tif (typeId == typeof(" + type + "))\n"\
                                                             "\t\t\t{\n" \
                                                       "\t\t\t\treturn " + str(key) + ";\n"\
                                                                                      "\t\t\t}\n"

    code = code + "\t\t\treturn 0;\n" \
                  "\t\t}\n\n"

    code += "\t\tpublic static int GetHashSize()\n" \
            "\t\t{\n" \
            "\t\t\treturn " + str(HASH_SIZE) + ";\n" \
                                             "\t\t}\n" \
                                             "\t}\n" \
                                             "} //namespace " + packageName.capitalize() + "\n"
    return code


def main():
    parser = argparse.ArgumentParser(prog='proto_hashgen', description='MD5 hash generator for nanopb')
    parser.add_argument("filename", type=str, help=".proto file name")
    parser.add_argument('-o', '--output', help='output file name', required=False, default="")
    parser.add_argument('-v', '--verbose', help='verbose mode', required=False, action='store_const', const=True,
                        default=False)
    parser.add_argument('-c', '--cpp', help='cpp header with hashes', required=False, action='store_const', const=True,
                        default=False)
    parser.add_argument('-j', '--json', help='json file with hashes', required=False, action='store_const', const=True,
                        default=False)
    parser.add_argument('-s', '--csharp', help='csharp header with hashes', required=False, action='store_const',
                        const=True,
                        default=False)

    args = parser.parse_args()
    path_input = args.filename
    filename_input = os.path.basename(path_input)

    path_output = args.output
    filename_output = os.path.basename(path_output)

    if not path_output:
        filename_output = filename_input.replace(".proto", "_hash")
        path_output = filename_output
    else:
        index = filename_output.rfind(".")
        if index > 0:
            filename_output = filename_output[:index]

    with open(path_input, 'r') as fin:
        data = fin.read()
        pattern = re.compile(
            r'//.*?$|/\*.*?\*/|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
            re.DOTALL | re.MULTILINE
        )
        # data = re.sub(r'/{2,2}.*\n', "", data)
        data = re.sub(pattern, "", data)
        for ch in [' ', '\t', '\n']:
            data = data.replace(ch, "")

    packageName = findPackage(data)
    messageNameDict = findMessage(data)
    enums = findEnum(data)
    if len(enums) > 0:
        messageNameDict.update(enums)

    findExtensions(data)

    if args.cpp:
        codeCpp = generateCpp(packageName, messageNameDict, filename_output + "_H", filename_input)
        with open(path_output + ".h", 'w') as fin:
            fin.write(codeCpp)

    if args.json:
        codeJson = generateJson(packageName, messageNameDict)
        with open(path_output + ".json", 'w') as fin:
            fin.write(codeJson)

    if args.csharp:
        codeCsharp = generateCsharp(packageName, messageNameDict)
        with open(path_output + ".cs", 'w') as fin:
            fin.write(codeCsharp)


if __name__ == "__main__":
    main()
